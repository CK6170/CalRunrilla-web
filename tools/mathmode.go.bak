package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"sort"
	"strings"

	matrix "github.com/CK6170/Calrunrilla-go/matrix"
)

// IterEntry matches the per-bar entries in the provided JSON
type IterEntry struct {
	ID int     `json:"ID"`
	LC []int64 `json:"LC"`
}

func main() {
	path := "math.json"
	outPath := ""
	if len(os.Args) > 1 {
		// allow: math.json [--out file.doc] or [--doc file.doc]
		// simple parsing: first non-flag is path
		args := os.Args[1:]
		for i := 0; i < len(args); i++ {
			a := args[i]
			if a == "--out" || a == "--doc" || a == "-o" {
				if i+1 < len(args) {
					outPath = args[i+1]
					i++
					continue
				}
			}
			if strings.HasPrefix(a, "--out=") || strings.HasPrefix(a, "--doc=") {
				parts := strings.SplitN(a, "=", 2)
				if len(parts) == 2 {
					outPath = parts[1]
					continue
				}
			}
			if !strings.HasPrefix(a, "-") && path == "math.json" {
				path = a
			}
		}
	}
	data, err := ioutil.ReadFile(path)
	if err != nil {
		log.Fatalf("read json: %v", err)
	}

	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		log.Fatalf("json unmarshal: %v", err)
	}

	// Get weight
	weight := 1000
	if v, ok := raw["WEIGHT"]; ok {
		var w int
		if err := json.Unmarshal(v, &w); err == nil {
			weight = w
		}
	}

	// Collect ITER keys like ITER0, ITER1, ... sort by numeric index
	iterKeys := make([]string, 0)
	for k := range raw {
		if len(k) >= 4 && k[:4] == "ITER" {
			iterKeys = append(iterKeys, k)
		}
	}
	sort.Slice(iterKeys, func(i, j int) bool { return iterKeys[i] < iterKeys[j] })
	if len(iterKeys) < 2 {
		log.Fatalf("need at least ITER0 and one ITERn entries")
	}

	// Parse ITER0
	var iter0 []IterEntry
	if err := json.Unmarshal(raw[iterKeys[0]], &iter0); err != nil {
		log.Fatalf("parse %s: %v", iterKeys[0], err)
	}
	nbars := len(iter0)
	if nbars == 0 {
		log.Fatalf("no bars in %s", iterKeys[0])
	}
	nlcs := len(iter0[0].LC)

	// Build adv rows from ITER1..end
	nloads := len(iterKeys) - 1
	// Validate expected nloads could be 3*(nbars-1)*nlcs but we accept provided length
	adv := matrix.NewMatrix(nloads, nbars*nlcs)
	for r := 0; r < nloads; r++ {
		var entries []IterEntry
		key := iterKeys[r+1]
		if err := json.Unmarshal(raw[key], &entries); err != nil {
			log.Fatalf("parse %s: %v", key, err)
		}
		if len(entries) != nbars {
			log.Fatalf("%s has %d bars, expected %d", key, len(entries), nbars)
		}
		// flatten
		row := make([]float64, nbars*nlcs)
		idx := 0
		for b := 0; b < nbars; b++ {
			if len(entries[b].LC) != nlcs {
				log.Fatalf("bar %d in %s has %d LCs, expected %d", b, key, len(entries[b].LC), nlcs)
			}
			for c := 0; c < nlcs; c++ {
				row[idx] = float64(entries[b].LC[c])
				idx++
			}
		}
		// convert row slice to matrix.Vector
		vr := matrix.NewVector(len(row))
		copy(vr.Values, row)
		adv.SetRow(r, vr)
	}

	// Build ad0 by repeating ITER0 vector for each adv row
	zeroRow := make([]float64, nbars*nlcs)
	idx := 0
	for b := 0; b < nbars; b++ {
		for c := 0; c < nlcs; c++ {
			zeroRow[idx] = float64(iter0[b].LC[c])
			idx++
		}
	}
	ad0 := matrix.NewMatrix(nloads, nbars*nlcs)
	for r := 0; r < nloads; r++ {
		vr := matrix.NewVector(len(zeroRow))
		copy(vr.Values, zeroRow)
		ad0.SetRow(r, vr)
	}

	fmt.Println(matrix.MatrixLine)
	fmt.Println("Zero Matrix (ad0)")
	fmt.Println(matrix.MatrixLine)
	fmt.Println(ad0.ToStrings("Zero Matrix", "%10.0f"))

	fmt.Println(matrix.MatrixLine)
	fmt.Println("Weight Matrix (adv)")
	fmt.Println(matrix.MatrixLine)
	fmt.Println(adv.ToStrings("Weight Matrix", "%10.0f"))

	add := adv.Sub(ad0)

	w := matrix.NewVectorWithValue(add.Rows, float64(weight))
	// Use transpose instead of pseudoinverse as requested: adi = add^T
	addT := transposeMatrix(add)
	adi := addT
	factors := adi.MulVector(w)
	if factors == nil {
		log.Fatalf("transpose multiplication failed")
	}
	// fFromTranspose is the same as factors
	fFromTranspose := factors

	// Print zeros
	zerosVec := ad0.GetRow(0)
	fmt.Println(matrix.MatrixLine)
	fmt.Println("zeros (from ITER0)")
	for i := 0; i < nbars; i++ {
		fmt.Printf("Bar %d zeros:\n", i+1)
		for j := 0; j < nlcs; j++ {
			idx := i*nlcs + j
			fmt.Printf("[%03d]  %12.0f\n", idx, zerosVec.Values[idx])
		}
		fmt.Println(matrix.MatrixLine)
	}

	// Print factors (decimal + IEEE)
	fmt.Println(matrix.MatrixLine)
	fmt.Println("factors (IEEE754)")
	for i, val := range factors.Values {
		hex := fmt.Sprintf("%08X", matrix.ToIEEE754(float32(val)))
		fmt.Printf("[%03d]  % .12f  %s\n", i, val, hex)
	}
	fmt.Println(matrix.MatrixLine)

	// Check
	check := add.MulVector(factors)
	fmt.Println(matrix.MatrixLine)
	fmt.Println("Check (add * factors)")
	for i := 0; i < check.Length; i++ {
		fmt.Printf("[%03d] %8.1f\n", i, check.Values[i])
	}
	fmt.Println(matrix.MatrixLine)

	norm := check.Sub(w).Norm() / float64(weight)
	fmt.Printf("Error: %e\n", norm)
	fmt.Printf("Pseudoinverse Norm: %e\n", adi.Norm())

	// If requested, write a report to outPath. For .html produce HTML, otherwise LaTeX.
	if outPath != "" {
		var content string
		lower := strings.ToLower(outPath)
		if strings.HasSuffix(lower, ".html") {
			content = buildHTMLReport(ad0, adv, add, factors, check, weight, norm, adi, addT, fFromTranspose, w)
		} else if strings.HasSuffix(lower, ".tex") {
			content = buildLaTeXReport(ad0, adv, add, factors, check, weight, adi, addT, fFromTranspose, w)
		} else {
			// default to LaTeX source if docx conversion expected
			content = buildLaTeXReport(ad0, adv, add, factors, check, weight, adi, addT, fFromTranspose, w)
		}
		if err := os.WriteFile(outPath, []byte(content), 0644); err != nil {
			log.Fatalf("failed to write %s: %v", outPath, err)
		}
		fmt.Printf("Wrote report to %s\n", outPath)
	}
}

func matrixToHTML(pm *matrix.Matrix) string {
	sb := &strings.Builder{}
	sb.WriteString("<table class=\"matrix\">\n")
	for i := 0; i < pm.Rows; i++ {
		sb.WriteString("  <tr>")
		for j := 0; j < pm.Cols; j++ {
			sb.WriteString(fmt.Sprintf("<td>%d</td>", int(pm.Values[i][j])))
		}
		sb.WriteString("</tr>\n")
	}
	sb.WriteString("</table>\n")
	return sb.String()
}

func vectorToHTML(v *matrix.Vector) string {
	sb := &strings.Builder{}
	sb.WriteString("<table class=\"vector\">\n")
	for i := 0; i < v.Length; i++ {
		sb.WriteString(fmt.Sprintf("  <tr><td>%0.6f</td></tr>\n", v.Values[i]))
	}
	sb.WriteString("</table>\n")
	return sb.String()
}

// Render float matrix as HTML table
func matrixFloatToHTML(pm *matrix.Matrix) string {
	sb := &strings.Builder{}
	sb.WriteString("<table class=\"matrix\">\n")
	for i := 0; i < pm.Rows; i++ {
		sb.WriteString("  <tr>")
		for j := 0; j < pm.Cols; j++ {
			sb.WriteString(fmt.Sprintf("<td>%0.6f</td>", pm.Values[i][j]))
		}
		sb.WriteString("</tr>\n")
	}
	sb.WriteString("</table>\n")
	return sb.String()
}

// transposeMatrix returns a new matrix which is the transpose of pm
func transposeMatrix(pm *matrix.Matrix) *matrix.Matrix {
	t := matrix.NewMatrix(pm.Cols, pm.Rows)
	for i := 0; i < pm.Rows; i++ {
		for j := 0; j < pm.Cols; j++ {
			// set t[j][i]
			vr := t.GetRow(j)
			vr.Values[i] = pm.Values[i][j]
			t.SetRow(j, vr)
		}
	}
	return t
}

func buildHTMLReport(ad0, adv, add *matrix.Matrix, factors, check *matrix.Vector, weight int, errVal float64, adi *matrix.Matrix, addT *matrix.Matrix, fFromTranspose *matrix.Vector, w *matrix.Vector) string {
	sb := &strings.Builder{}
	sb.WriteString("<!doctype html><html><head><meta charset=\"utf-8\"><style>")
	sb.WriteString("body{font-family:Arial,Helvetica,sans-serif;margin:20px}table.matrix,table.vector{border-collapse:collapse;margin-bottom:12px}table.matrix td,table.vector td{border:1px solid #ccc;padding:6px;text-align:right}")
	sb.WriteString("h2{color:#333}")
	sb.WriteString("</style></head><body>\n")
	// Include MathJax for LaTeX equation rendering
	sb.WriteString("<script src=\"https://polyfill.io/v3/polyfill.min.js?features=es6\"></script>\n")
	sb.WriteString("<script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"></script>\n")
	sb.WriteString(fmt.Sprintf("<h1>CalRunrilla report</h1><p><strong>Weight:</strong> %d</p>\n", weight))

	sb.WriteString("<h2>Zero matrix (ad0)</h2>\n")
	sb.WriteString(matrixToHTML(ad0))
	sb.WriteString("<h2>Weight matrix (adv)</h2>\n")
	sb.WriteString(matrixToHTML(adv))
	sb.WriteString("<h2>Difference (adv - ad0)</h2>\n")
	sb.WriteString(matrixToHTML(add))

	sb.WriteString("<h2>Factors (decimal)</h2>\n")
	sb.WriteString(vectorToHTML(factors))
	sb.WriteString("<div>\\(f = \\begin{pmatrix}")
	// inline factors as LaTeX pmatrix
	for i := 0; i < factors.Length; i++ {
		if i > 0 {
			sb.WriteString("\\\\")
		}
		sb.WriteString(fmt.Sprintf("%0.6f", factors.Values[i]))
	}
	sb.WriteString("\\end{pmatrix}\\)</div>\n")

	sb.WriteString("<h2>Check (add * factors)</h2>\n")
	sb.WriteString(vectorToHTML(check))

	// Matrix-format equations: add = adv - ad0
	sb.WriteString("<h2>Matrix equations</h2>\n")
	sb.WriteString("<div>\\[")
	sb.WriteString(matrixToLaTeX(add))
	sb.WriteString(" = ")
	sb.WriteString(matrixToLaTeX(adv))
	sb.WriteString(" - ")
	sb.WriteString(matrixToLaTeX(ad0))
	sb.WriteString("\\]</div>\n")

	// Show pseudoinverse numeric table
	sb.WriteString("<h2>Pseudoinverse (adi)</h2>\n")
	sb.WriteString(matrixFloatToHTML(adi))

	// adi = add^T symbolic and numeric
	sb.WriteString("<h3>Transpose relation</h3>\n")
	sb.WriteString("<div>\\[")
	sb.WriteString(matrixFloatToLaTeX(adi))
	sb.WriteString(" = ")
	sb.WriteString(matrixToLaTeX(add))
	sb.WriteString("^{T}\\]</div>\n")
	// show numeric add^T
	sb.WriteString("<h4>add^T (numeric)</h4>\n")
	sb.WriteString(matrixFloatToHTML(addT))

	// f = adi * w
	sb.WriteString("<h3>f = adi &middot; w</h3>\n")
	sb.WriteString("<div>\\[")
	sb.WriteString(matrixFloatToLaTeX(adi))
	sb.WriteString(" \\cdot ")
	sb.WriteString(vectorToLaTeX(w))
	sb.WriteString(" = ")
	sb.WriteString(vectorToLaTeX(fFromTranspose))
	sb.WriteString("\\]</div>\n")

	// Per-factor expansions: adi_row * w = factor
	sb.WriteString("<h3>Per-factor calculation</h3>\n")
	for i := 0; i < factors.Length; i++ {
		// build expression like (a_i0 * w0 + a_i1 * w1 + ...) = factor_i
		expr := &strings.Builder{}
		for j := 0; j < adi.Cols; j++ {
			if j > 0 {
				expr.WriteString(" + ")
			}
			expr.WriteString(fmt.Sprintf("%0.6f*%0.6f", adi.Values[i][j], w.Values[j]))
		}
		expr.WriteString(fmt.Sprintf(" = %0.6f", factors.Values[i]))
		// put as MathJax inline for clarity
		sb.WriteString("<div>\\(")
		sb.WriteString(expr.String())
		sb.WriteString("\\)</div>\n")
	}

	sb.WriteString("<h2>Diagnostics</h2>\n")
	sb.WriteString(fmt.Sprintf("<p><strong>Error (normalized):</strong> %e</p>", errVal))
	sb.WriteString(fmt.Sprintf("<p><strong>Pseudoinverse Norm:</strong> %e</p>", adi.Norm()))

	// Equations: show multiplication and transpose
	sb.WriteString("<h2>Equations</h2>\n")
	// Build LaTeX equation for add * factors = check
	eq := &strings.Builder{}
	eq.WriteString(matrixToLaTeXEquation(add))
	eq.WriteString(" \\cdot ")
	eq.WriteString(vectorToLaTeXEquation(factors))
	eq.WriteString(" = ")
	eq.WriteString(vectorToLaTeXEquation(check))
	// factors transpose
	eq.WriteString("\\\n")
	eq.WriteString(vectorToLaTeXEquation(factors))
	eq.WriteString("^{T} = ")
	eq.WriteString(vectorToLaTeXTranspose(factors))
	sb.WriteString("<div>$$")
	sb.WriteString(eq.String())
	sb.WriteString("$$</div>\n")

	sb.WriteString("</body></html>\n")
	return sb.String()
}

// Produce LaTeX equation for a matrix (pmatrix)
func matrixToLaTeXEquation(pm *matrix.Matrix) string {
	sb := &strings.Builder{}
	sb.WriteString("\\begin{pmatrix}")
	for i := 0; i < pm.Rows; i++ {
		if i > 0 {
			sb.WriteString("\\\\")
		}
		for j := 0; j < pm.Cols; j++ {
			if j > 0 {
				sb.WriteString(" & ")
			}
			sb.WriteString(fmt.Sprintf("%d", int(pm.Values[i][j])))
		}
	}
	sb.WriteString("\\end{pmatrix}")
	return sb.String()
}

// Produce LaTeX equation for a vector
func vectorToLaTeXEquation(v *matrix.Vector) string {
	sb := &strings.Builder{}
	sb.WriteString("\\begin{pmatrix}")
	for i := 0; i < v.Length; i++ {
		if i > 0 {
			sb.WriteString("\\\\")
		}
		sb.WriteString(fmt.Sprintf("%0.6f", v.Values[i]))
	}
	sb.WriteString("\\end{pmatrix}")
	return sb.String()
}

// Produce LaTeX for the transpose of a vector (row vector)
func vectorToLaTeXTranspose(v *matrix.Vector) string {
	sb := &strings.Builder{}
	sb.WriteString("\\begin{pmatrix}")
	for i := 0; i < v.Length; i++ {
		if i > 0 {
			sb.WriteString(" & ")
		}
		sb.WriteString(fmt.Sprintf("%0.6f", v.Values[i]))
	}
	sb.WriteString("\\end{pmatrix}")
	return sb.String()
}

func matrixToLaTeX(pm *matrix.Matrix) string {
	sb := &strings.Builder{}
	sb.WriteString("\\begin{pmatrix}\n")
	for i := 0; i < pm.Rows; i++ {
		for j := 0; j < pm.Cols; j++ {
			if j > 0 {
				sb.WriteString(" & ")
			}
			sb.WriteString(fmt.Sprintf("%v", int(pm.Values[i][j])))
		}
		if i < pm.Rows-1 {
			sb.WriteString(" \\\\")
			sb.WriteString("\n")
		} else {
			sb.WriteString("\n")
		}
	}
	sb.WriteString("\\end{pmatrix}\n")
	return sb.String()
}

func vectorToLaTeX(v *matrix.Vector) string {
	sb := &strings.Builder{}
	sb.WriteString("\\begin{pmatrix}")
	for i := 0; i < v.Length; i++ {
		if i > 0 {
			sb.WriteString(" \\\\ ")
		}
		sb.WriteString(fmt.Sprintf("%0.6f", v.Values[i]))
	}
	sb.WriteString("\\end{pmatrix}\n")
	return sb.String()
}

func buildLaTeXReport(ad0, adv, add *matrix.Matrix, factors, check *matrix.Vector, weight int, adi *matrix.Matrix, addT *matrix.Matrix, fFromTranspose *matrix.Vector, w *matrix.Vector) string {
	sb := &strings.Builder{}
	sb.WriteString("\\documentclass{article}\n")
	sb.WriteString("\\usepackage{amsmath}\n")
	sb.WriteString("\\usepackage{amsfonts}\n")
	sb.WriteString("\\usepackage{amssymb}\n")
	sb.WriteString("\\begin{document}\n")
	sb.WriteString("% CalRunrilla LaTeX report\n")
	sb.WriteString(fmt.Sprintf("%% Weight: %d\n\n", weight))

	sb.WriteString("\\section*{Zero matrix (ad0)}\n")
	sb.WriteString(matrixToLaTeX(ad0))
	sb.WriteString("\\section*{Weight matrix (adv)}\n")
	sb.WriteString(matrixToLaTeX(adv))
	sb.WriteString("\\section*{Difference (adv - ad0)}\n")
	sb.WriteString(matrixToLaTeX(add))

	sb.WriteString("\\section*{Factors (decimal)}\n")
	sb.WriteString(vectorToLaTeX(factors))

	sb.WriteString("\\section*{Check (add * factors)}\n")
	sb.WriteString(vectorToLaTeX(check))

	// Matrix-format equations
	sb.WriteString("\\section*{Matrix equations}\\\n")
	sb.WriteString("\\[")
	sb.WriteString(matrixToLaTeX(add))
	sb.WriteString(" = ")
	sb.WriteString(matrixToLaTeX(adv))
	sb.WriteString(" - ")
	sb.WriteString(matrixToLaTeX(ad0))
	sb.WriteString("\\]\\n")

	// adi = add^T
	sb.WriteString("\\[\\mathrm{adi} = ")
	sb.WriteString(matrixFloatToLaTeX(adi))
	sb.WriteString(" = ")
	sb.WriteString(matrixToLaTeX(add))
	sb.WriteString("^{T}\\]\\n")

	// f = adi * w
	sb.WriteString("\\[")
	sb.WriteString(matrixFloatToLaTeX(adi))
	sb.WriteString(" \\cdot ")
	sb.WriteString(vectorToLaTeX(w))
	sb.WriteString(" = ")
	sb.WriteString(vectorToLaTeX(fFromTranspose))
	sb.WriteString("\\]\\n")

	// Per-factor expansions using align*
	sb.WriteString("\\begin{align*}\n")
	for i := 0; i < factors.Length; i++ {
		// build left-hand side
		lhs := &strings.Builder{}
		for j := 0; j < adi.Cols; j++ {
			if j > 0 {
				lhs.WriteString(" + ")
			}
			lhs.WriteString(fmt.Sprintf("%0.6f\\cdot %0.6f", adi.Values[i][j], w.Values[j]))
		}
		sb.WriteString(fmt.Sprintf("%s & = %0.6f\\\\\n", lhs.String(), factors.Values[i]))
	}
	sb.WriteString("\\end{align*}\n")

	sb.WriteString("\\section*{Diagnostics}\n")
	// error and adi.Norm printed earlier; include placeholders here
	sb.WriteString("% Error and pseudoinverse norm included in console output.\n")
	sb.WriteString("\\end{document}\n")
	return sb.String()
}

// Render a matrix of floats as LaTeX pmatrix
func matrixFloatToLaTeX(pm *matrix.Matrix) string {
	sb := &strings.Builder{}
	sb.WriteString("\\begin{pmatrix}")
	for i := 0; i < pm.Rows; i++ {
		if i > 0 {
			sb.WriteString("\\\\")
		}
		for j := 0; j < pm.Cols; j++ {
			if j > 0 {
				sb.WriteString(" & ")
			}
			sb.WriteString(fmt.Sprintf("%0.6f", pm.Values[i][j]))
		}
	}
	sb.WriteString("\\end{pmatrix}")
	return sb.String()
}
